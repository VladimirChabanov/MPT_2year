# Практическое задание 2. Знакомство с Jenkins.

**Цель:** Ознакомиться на практике со средствами CI/CD доступными в Jenkins.

## Теоретическая часть

Рекомендуется ознакомится с материалами из раздела "Полезные ссылки".

## Задания к практической работе

Каждую выполненную вам команду и результат её работы поместите в отчёт в виде скриншота.

### Установка

1. Скачать Jenkins можно с [официального сайта](https://www.jenkins.io/download/). Здесь доступно множество вариантов, под разные ОС, в том числе и Jenkins запакованный в Docker-контейнер. В этой работе мы будем устанавливать Jenkins с нуля на Ubuntu.
2. Создайте новую виртуальную машину с Ubuntu Server-ом в качестве имени пользователя выберите любое кроме `jenkins`. В процессе установки можете выбрать автоматическую установку ssh-сервера и docker.  
   На этом сервере будет выполняться сборка и тестирование приложения.
3. В настройках VirutalBox переключите Сеть виртуальной машины в режим "Сетевой мост", затем залогиньтесь и определите ip-адрес машины (в моем случае это: 192.168.1.40). С хостовой машины установите соединение с сервером по ssh с помощью любого, удобного для вас, ssh-клиента.  
   Таким образом будет удобнее выполнять последующие шаги, т.к. можно будет просто копипастить команды.
4. Перейдите на оф. сайт Jenkins в [раздел установки](https://www.jenkins.io/doc/book/installing/linux/#debianubuntu) и установите на сервер сначала Java, а затем и сам Jenkins. Просто последовательно копируйте и запускайте команды указанные в инструкции. Если строка заканчивается на символ `\`, то такие строки нужно копировать по одной, т.к. после `\` ожидается нажатие Enter.

   - Для Jenkins можно выбрать один из вариантов: "Long Term Support release" или "Weekly release". Для этой работы разницы нет, но в "Long Term Support release" обычно меньше багов, т.к. релиз не самый последний и баги уже могли успеть исправить;
   - Инструкция по установке Java расположена под инструкцией по установке Jenkins.
5. Теперь нужно выполнить начальную конфигурацию Jenkins через web-интерфейс.  
   Т.к. машина с сервером на котором установлен Jenkins находится в одной сети с нашей хвостовой машиной, мы можем получить доступ к Jenkins через браузер на хвостовой машине, просто указав в адресной строке браузера ip-адрес сервера и порт 8080 (стандартный порт для Jenkins). В моем случае это: 192.168.1.40:8080.
6. Сначала Jenkins попросит доказать, что вы действительно владелец сервера, для этого нужно скопировать в поле ввода в браузере содержимое файла `/var/lib/jenkins/secrets/initialAdminPassword` расположенного на сервере. Его можно открыть любым текстовым редактором (через `sudo`).
7. Теперь Jebkins предложит выбрать список плагинов для установки. Все плагины можно будет легко установить/удалить в любое время, поэтому выберите любую из кнопок:

   - Install suggested plugins - автоматически установит набор популярных плагинов;
   - Select plugins to install - перед установкой позволит выбрать что устанавливать.
8. Создайте пользователя для управления Jenkins. По умолчанию у него будут права администратора. Эти логин и пароль нужно будет вводить при входе в web-интерфейс Jenkins.
9. По умолчанию Jankins определяет язык интерфейса по настройкам браузера, поэтому вместо английского вы можете увидеть русский текст. Иногда удобнее использовать английский интерфейс (проще гуглить). Если хотите можете оставить русский, но чтобы получить возможность переключить интерфейс на английский язык нужно установить плагин:
   - Выберите в меню слева пункт "Настроить Jenkins" ("Manage Jenkins"), а затем "Управление плагинами" ("Manage Plugins");
   - После этого меню слева переключится в режим управления плагинами. Выберите пункт "Доступные плагины" ("Available plugins") и в строку поиска вбейте "Locale plugin";
   - Поставьте галочку рядом с "Locale plugin" и нажмите кнопку "Download now and install after restart". Плагин проверит зависимости и через некоторое время начнёт установку.
   - В самом низу поставьте галочку "Перезапустить Jenkins по окончанию установки и отсутствии активных задач". Вкладка может не обновится автоматически, поэтому обновите её вручную через некоторое время.
   - Выберите в меню слева пункт "Настроить Jenkins" ("Manage Jenkins"), а затем "Конфигурация системы" ("Configure System");
   - Пролистайте вниз до раздела "Locale". В нем будет поле под названием "Язык по умолчанию" ("Default Language"). Введите "en" или "ENGLISH";
   - В этом же разделе поставьте галочку "Игнорировать настройки браузера и принудительно использовать этот язык для всех пользователей" ("Ignore browser preference and force this language to all users");
   - После того, как вы нажмёте кнопку "Применить" настройки вступят в силу.

### Простой job

Сейчас мы создадим самый просто job с настройками по умолчанию. Job будет состоять только из одного шага в результате которого на сервере будут запущены несколько обычных shell-команд.

1. Чтобы создать новое задание (job) для Jenkins:

   - в меню слева нажмите  кнопку "New Item";
   - введите имя job-a;
   - из списка возможных вариантов выберите первый "Freestyle project" и нажмите кнопку OK.

2. Пролистайте страницу до раздела "Build Steps" и нажмите кнопку "Add build step" в выпадающем списке выберите "Execute shell". В зависимости от установленных плагинов в этом списке могут быть доступны дополнительные варианты позволяющие выполнять некоторые шаги проще.

3. В появившемся поле ввода наберите:  
   ```bash
   echo $JOB_NAME
   whoami
   pwd
   ls -al
   ```

   В первой строке, мы используем переменную окружения, которую устанавливает Jenkins. В данном случае в переменной `JOB_NAME` хранится имя которое мы дали job-у при создании. В этих переменных хранится много полезной информации, поэтому изучите их (ссылка на список доступна в этом же разделе).  
   Остальные три строки, это обычные shell-команды, которые покажут пользователя от чьего имени выполняется данный скрипт, текущий каталог и его содержимое.

4. После того, как вы нажмёте кнопку "Save" job будет сохранён и вас перекинет в меню управления текущим job-ом.  
   ![](./task_02_img/job_dash.png)

5. Запустите job при помощи кнопки "Build Now".  
   Через несколько секунд вы увидите, что в разделе "Build History" появится первый/новый пункт.

6. Щёлкнув по этому пункту вы попадёте раздел управления результатами сборки. Здесь нас интересует пункт меню "Console Output". Изучите свой вывод.  
   ![](./task_02_img/job_out.png)

   Как видно, название job-a у меня "Simple"; скрипт выполнялся от имени пользователя "jenkins"; текущим каталогом был "/var/lib/jenkins/workspace/Simple" и в данный момент он пустой и принадлежит пользователю "jenkins".

7. Если вы перейдёте в раздел "Dashboard" (корень сайта), то обнаружите свой job и здесь.

### Сборка проекта с GitHub

Здесь мы создадим job который получит файлы проекта с GitHub, установит зависимости и запустит проект.

#### Подготовка репозитория

1. Создайте новый каталог на машине, на которой у вас есть утилита git.

2. Создайте три файла со следующим содержимым:

   - ReadMe.md  
     ```markdown
     # Pure python QR Code generator
     ```

   - main.py  
     ```python
     import qrcode
     img = qrcode.make('Some data here')
     img.save("some_file.png")
     ```

   - requirements.txt  
     ```
     qrcode[pil]
     ```

3. Инициируйте в этой папке локальный репозиторий и закоммитьте содержимое.

4. Создайте на github.com репозиторий и синхронизируйте его с локальным. В моём случае это [qr_code_generator](https://github.com/VladimirChabanov/qr_code_generator/tree/efd97701189b9db6eb0a1c601119129058a5c567).

#### Создаём и настраиваем job

1. Создайте новый job типа "Freestyle project".

2. Т.к. у нас уже установлен [Git plugin](https://plugins.jenkins.io/git), то в настройках job-a у нас будет раздел "Source Code Management". В этом разделе нужно установить переключатель на Git (по умолчанию None).

3. В развернувшемся подразделе найдите поле "Repository URL" и вставьте ссылку на созданный ранее GitHub-репозиторий. Ссылку можно получить щёлкнув по зелёной кнопке "Code" на странице репозитория. Пока нам достаточно https ссылки (чтобы не тратить время на настройку ssh).

4. Чуть ниже в поле "Branch Specifier" написано `*/master`. Эту ветку Jenkins попробует получить из  репозитория. Но в нашем репо такой ветки нет. На стадии синхронизации с GitHub мы переименовали её в "main" (командой `git branch -M main`).  
   Замените `*/master` на `*/main`.

5. Перейдите в раздел "Build Steps" и создайте step типа "Execute shell" содержащий команду: `ls -al`.

6. Сохраните и запустите job.

7. После выполнения job-а, посмотрите консольный вывод. Вы должны увидеть, что в текущем рабочем каталоге присутствуют все файлы из репозитория.

8. Вернитесь на страницу управления job-ом и нажмите кнопку "Configure", чтобы изменить job.

9. В разделе "Build Steps" замените `ls -al` на:  
   ```bash
   #!/bin/bash
   python3 -m venv venv
   source venv/bin/activate
   pip install -r requirements.txt
   python main.py
   ```

10. Сохраните и запустите job.

11. Этот запуск должен завершится неудачно. Если вы изучите консольный вывод, то обнаружите, что причина в отсутствии `venv`.  
    Все команды, которые выполняет Jenkins запускаются на той машине, на которой он установлен, т.е. на нашем Ubuntu Server-е. Следовательно, прежде, чем что-то запускать, нужно позаботиться, чтобы оно было установлено.

12. На сервере (через ssh или напрямую) установите `venv` и `pip`.

13. Вернитесь обратно в Jenkins и запустите job повторно.  
    Теперь всё должно выполнится успешно, а в рабочем каталоге должен появится файл "some_file.png". Убедитесь в этом при помощи пункта "Workspace" со страницы управления job-ом.

### Автоматизация сборки проекта с GitHub

Здесь мы настроим процесс автоматического запуска job-а при обнаружении изменений в GitHub-репозитории.

#### Запуск по таймеру

1. Создайте новый job типа "Freestyle project".

2. В разделе "Source Code Management" укажите те же настройки, что и ранее.

3. В разделе "Build Triggers" перечислены источники событий, которые могут инициировать запуск job-a. Поставьте галочку напротив триггера "Poll SCM". Этот триггер будет опрашивать GitHub в соответствии с заданной периодичностью и в случае обнаружения изменений будет запускаться job.

4. В развернувшемся подразделе "Schedule" нужно указать периодичность опроса репозитория в формате cron. Для этого можно воспользоваться подсказкой или онлайн генераторами. Введите в это поле строку: `H/2 * * * *`.  
   Здесь мы просим автоматически проверять репозиторий каждую чётную минуту.

5. Перейдите в раздел "Build Steps" и создайте step типа "Execute shell" содержащий:  
   ```bash
   #!/bin/bash
   python3 -m venv venv
   source venv/bin/activate
   pip install -r requirements.txt
   python main.py
   ```

6. Сохраните job, но НЕ запускайте его вручную. Подождите до ближайшей чётной минуты и job должен будет запуститься автоматически. Затем подождите ещё 3-5 минут. Т.к. репозиторий не изменялся, то и новых запусков в истории появляться не должно.

7. Теперь, в локальном репозитории, QR код генератора измените содержимое файла "main.py" на следующее:  
   ```python
   import qrcode
   img = qrcode.make('Other data here')
   img.save("other_file.png")
   ```

8. Закоммитьте и отправьте изменения на GitHub.

9. Подождите ближайшей чётной минуты и вы должны увидеть, что запустился новый процесс сборки, а в рабочем каталоге появился файл "other_file.png".

10. Минус данного метода в том, что мы вынуждены постоянно выполнять проверку репозитория, при этом нагружая свой сервер и сервера GitHub. Поэтому, чтобы не напрягать GitHub своими запросами зайдите в "Configure" и выключите job. Переключатель вверху страницы переведите из положения "Enabled" в "Disabled".

#### Запуск по событию

1. Создайте новый job типа "Freestyle project".

2. В самом верху можно поставить галочку "GitHub project" и указать URL GitHub репозитория (тоже, что и ранее, но без .git в конце). Этот пункт не обязательный, он приведёт к тому, что в некоторых местах появится ссылка позволяющая перейти на GitHub и больше ничего.

3. В разделе "Source Code Management" укажите те же настройки, что и ранее.

4. В разделе "Build Triggers" поставьте галочку напротив триггера "GitHub hook trigger for GITScm polling". Этот триггер будет запускать job, только в том случае, если GitHub сообщит Jenkins-у о наступлении интересующего нас события (нас будет интересовать `push`).  
   Т.е. не мы дёргаем GitHub, а GitHub уведомляет нас.

5. Перейдите в раздел "Build Steps" и создайте step типа "Execute shell" содержащий:  

   ```bash
   #!/bin/bash
   python3 -m venv venv
   source venv/bin/activate
   pip install -r requirements.txt
   python main.py
   ```

6. Сохраните job, но НЕ запускайте его вручную.

7. На данном этапе Jenkins ждёт уведомлений от GitHub, но GitHub об этом не подозревает. Т.е. теперь мы должны настроить GitHub таким образом, чтобы он отправлял сообщения нашему Jenkins-у.

8. Чтобы GitHub знал кого ему нужно уведомлять о событиях, ему нужно предоставить Webhook (т.е. ссылку), но с этим есть определённая проблема (если у вас не белый IP). Виртуальная машина находится за NAT, и следовательно, снаружи к ней доступа нет.  
   Чтобы решить эту проблему воспользуемся ngrok:

   - Откройте раздел Download на [оф. сайте](https://ngrok.com/download);
   - Скопируйте команду из "Install ngrok via Apt", чтобы установить ngrok через `apt`;
   - Вставьте и выполните её в терминале (через ssh или напрямую);
   - Чтобы ngrok работал понадобится токен, который можно получить в [личном кабинете](https://dashboard.ngrok.com/get-started/your-authtoken) после регистрации. Там же будет команда которую нужно выполнить, чтобы привязать ngrok к аккаунту. Что-то вроде: `ngrok config add-authtoken ваш_токен`.  
     Копируйте её и запускайте в терминале.
   - Запустите ngrok командой: `ngrok --log=stdout http 8080 > ngrok.log &`.  
     Здесь мы просим ngrok, чтобы он пробрасывал http запросы на порт 8080 (это порт Jenkins-а), при этом весь вывод ngrok-а мы перенаправляем в файл ngrok.log (название может быть любым), при этом сам ngrok запускается в фоновом режиме (символ `&` в конце), чтобы он не блокировал терминал.
   - В результате будет сгенерирована ссылка которая будет выполнять роль web-хука для GitHub. Т.к. весь вывод ngrok перенаправляет в файл "ngrok.log", то и нужным нам адрес находится там же.
     Выполните: ` cat ngrok.log | grep url=`. В выводе будет требуемая ссылка.
   - Скопируйте её и вставите в адресную строку браузера. Если в результате откроется Jenkins значит ссылка работает.

9. Перейдите на GitHub в репозиторий с проектом QR код генератора. Перейдите в раздел "Settings" и в левом меню выберите пункт "Webhooks", а затем нажмите кнопку "Add webhook".

10. В поле "Payload URL" вставьте ссылку полученную от ngrok к которой добавьте `/github-webhook/`. В списке "Content type" выберите "application/json". В разделе "Which events would you like to trigger this webhook?" можно выбрать разные события, которые будут приводить к отправке сообщения по webhook-у, но нас интересует только `push`, поэтому оставляем дефолтное значение "Just the push event".  
    ![](./task_02_img/github_webhook.png)

11. Теперь, в локальном репозитории, QR код генератора измените содержимое файла "main.py" на следующее:  

    ```python
    import qrcode
    img = qrcode.make('GitHub Webhook')
    img.save("gitHub_webhook.png")
    ```

12. Закоммитьте и отправьте изменения на GitHub.

13. Откройте Jenkins и теперь вы должны увидеть, что сборка была выполнена.

14. Минус данного метода в том, что мы зависим от ngrok и в случае перезапуска сервера или самого ngrok-a, будет сгенерирована новая ссылка, а значит придётся вносить изменения и на GitHub. Но если у вашего сервера есть белый IP, то данный метод очень хороший.

### Автоматизация отправки на DockerHub

Здесь мы настроим процесс автоматического запуска job-а при обнаружении изменений в GitHub-репозитории, упаковки приложения в Docker-контейнер и отправки его на DockerHub.

На данном этапе нам понадобится установленный на сервере Docker. Как оказалось, если вы поставили галочку на этапе установки сервера, то происходит установка Docker через `snap`, а не через `apt`. Такой вариант нам не подходит, т.к. это приведёт, к проблемам с Jenkins.  
Домашний каталог пользователя jenkins расположен не в "/home/", а в "/var/lib/" и `span` версия Docker не может с ним работать.  
Если вы установили Docker в процессе установки сервера его нужно удалить командой: `sudo snap remove docker`. Затем установить Docker при помощи `apt` руководствуясь [инструкцией](https://docs.docker.com/engine/install/ubuntu/) с оф. сайта.

После установки добавьте пользователя jenkins (можно и основного тоже) в группу docker, чтобы он мог запускать команды без sudo:

```
sudo usermod -aG docker jenkins
sudo usermod -aG docker $USER
```

Перезагрузите сервер.

1. Прежде, чем перейдём к созданию job-a изменим исходный код нашего проекта. Для этого замените содержимое файла "main.py" в локальном репозитории на:

   ```python
   import qrcode
   import base64
   from flask import Flask
   from flask import request
   from io import BytesIO
   
   app = Flask(__name__)
   
   @app.route("/qr")
   def qr():
      msg = request.args.get('msg')
      img = qrcode.make(msg)
      
      buffer = BytesIO()
      img.save(buffer, format="png")
    
      img64 = base64.b64encode(buffer.getvalue())
      return f'<img src="data:image/png;base64, {img64.decode()}" alt="qrcode" />'
   
   
   if __name__ == "__main__":
      app.run(host='0.0.0.0')
   ```

   А содержимое файла "requirements.txt" на:

   ```
   qrcode[pil]
   flask
   ```

2. Закомитьтте изменения.

3. Далее добавим в репозиторий QR код генератора Dockerfile.

4. В корне локального репозитория создайте каталог "docker" и в этом каталоге создайте Dockerfile со следующим содержимым:

   ```dockerfile
   FROM python:3.8-alpine3.17
   WORKDIR /app
   COPY requirements.txt /app
   COPY main.py /app
   RUN pip install -r requirements.txt
   ENTRYPOINT [ "python" ]
   CMD [ "main.py" ]
   ```

5. Закомитьтте изменения и отправьте их на GitHub.

6. Перейдите в Jenkins и создайте новый job типа "Freestyle project".

7. В разделе "Source Code Management" укажите те же настройки, что и ранее.

8. Перейдите в раздел "Build Steps" и создайте step типа "Execute shell" содержащий:  

   ```bash
   docker build --file=docker/Dockerfile -t qrcode .
   ```

   Ключ `--file` позволяет определять произвольный путь к Dockerfile-у (по умолчанию он ищется в текущей папке); `-t` позволяет определить имя нового образа и тег (по умолчанию latest); точка в конце - это "контекст", относительно "контекста" вычисляются все пути прописанные в Dockerfile (у нас это текущая папка).

9. Добавьте ещё один шаг типа "Execute shell" содержащий:

   ```bash
   docker run --rm --name=qrcodegen -d -p 5000:5000 qrcode
   sleep 5
   ```

   Запускаем контейнер из образа "qrcode" в фоновом режиме (`-d`). Имя контейнеру назначаем "qrcodegen" и просим удалять его автоматически после остановки (`--rm`). Для доступа внутрь контейнера пробрасываем внешний порт 5000 на внутренний порт 5000 (его, по умолчанию, слушает flask).  
   Команды `sleep 5` - это "костыль", который служит для того, чтобы дать docker-у время полноценно запустить контейнер. Без этого костыля следующий шаг начнёт выполняться до того, как приложение в контейнере будет готово к работе.

10. Добавьте ещё один шаг типа "Execute shell" содержащий:

    ```bash
    curl localhost:5000/qr?msg=hello
    ```

    Используем утилиту "curl" чтобы послать запрос нашему приложению. В ответ, приложение сгенерирует qr код с текстом "hello", затем преобразует изображение в строку в формате base64  и пришлёт его заверну в тег `img`   
    Вывод этой команды должен содержать текст:

    ```
    <img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAASIAAAEiAQAAAAB1xeIbAAABfElEQVR4nO2YS27DMAxEH2vtFaAHyFGsG/TK8VF6A2sZwMF0IblO+kG7Uew41EIQiAd4IFA0OSb+XsPLPyBwyimnnHJq65TVFWCwAOQ5klbV9RRUL0kawVKcADpJkm6p++t6CirXHNeJSzmVZ7C2rj1T4Wugfw+I3O6LTv1GmR0lS3f84vNSc95HARmWUet66Nqq+l1Qg5mZHcBSDgCX0uasrWvXVMn762zPF6vPYE1dz0BRWsl+7MqmU5zmmOpJp62qf2yq3q7GThDrqW6aauPvd9+SGo5nk94DtejHyfv75lStL0SpDrfSVd57zWlO6ZSriwM5YAmwROeeQksK3a4SKz/cEa/37anFxyw3Tg4/UPfXtW/qs59cWhyAOLc4Xu/bU7OPaYla/hdHc/vqH5P66mNqOAr68QDkwzzwblX9vihLOWApSpboZkdzfV17pL75mMPbiMivE8Szed43pFg6SygNfSf6EdxTaE199zHLJsBnK6eccsqp/VAfweHzVhgEgGwAAAAASUVORK5CYII=" alt="qrcode" />
    ```

11. Добавьте ещё один шаг типа "Execute shell" содержащий:

    ```bash
    docker stop qrcodegen
    ```

    Останавливаем контейнер по имени. После остановки он сразу будет удалён.

12. Сохраните и запустите job вручную. Оцените консольный вывод и если ошибок нет, то переходите к следующему шагу.  
    **Внимание:** если в процессе работы job-а возникнут ошибки, то шаг выполняющий удаление остановку и удаление контейнера может не выполниться. В результате, при следующем запуске job-а Docker будет ругаться, что имя и(или) порт уже используются. Поэтому если job завершился неудачно, то остановите контейнер вручную (например выполнив команду через ssh терминал).

13. Теперь нужно настроить отправку контейнера на DockerHub. Но для этого придётся войти в свою учётную запись.  
    Чтобы не приписывать логин и пароль в открытом виде добавим их в специальное хранилище учётных данных (Credentials).

    - В разделе "Build Environment" (выше "Build Steps") поставьте галочку напротив пункта "Use secret text(s) or file(s)".
    - В развернувшемся подразделе нажмите на кнопку "Add" и выберите "Username and password (separated)".  А затем заполните поля "Username Variable" и "Password Variable" значениями "DOCHUB_USERNAME" и "DOCHUB_TOKEN" соответственно.  Под этими именами будут доступны наши учётные данные от DockerHub на каждом step-е job-a.  
      ![](./task_02_img/secret.png)
    - Нажмите кнопку "+ Add" и в развернувшемся списке выберите единственный доступный вариант: "Jenkins";
    - В открывшемся окне введите логин и пароли от DockerHub, а также поле ID.  
      ![](./task_02_img/log_pas.png)
    - После того, как вы нажмёте "Add" окно загореться, а в поле "Credentials" будут выбраны только что введённые значения. В дальнейшем (в других job-ax) повторный ввод логина и пароля не потребуется, они сразу же будет доступны в списке.

14. Перейдите в раздел "Build Steps" и создайте step типа "Execute shell" содержащий:  

    ```bash
    docker login -u $DOCHUB_USERNAME -p $DOCHUB_TOKEN
    ```

15. Добавьте ещё один шаг типа "Execute shell" содержащий:

    ```bash
    #!/bin/bash
    docker tag qrcode:latest $DOCHUB_USERNAME/qrcode:${GIT_COMMIT::7}
    ```

    Здесь мы добавляем нашему образу "qrcode:latest" новое имя состоящее из логина на DockerHub имени образа и обрезанного до 7 символов хэша коммита. (`GIT_COMMIT` - это переменная окружения, которую предоставляет Jenkins).

16. Следующим шагом выполняем push на DockerHub:

    ```bash
    #!/bin/bash
    docker push $DOCHUB_USERNAME/qrcode:${GIT_COMMIT::7}
    ```

17. Сохраните job.

18. Откройте [DockerHub](https://hub.docker.com/) залогиньтесь под своим аккаунтом (может понадобиться VPN) и создайте репозиторий "qrcode".

19. Запустите job в ручном режиме.  
    В результате его выполнения на сайте [DockerHub](https://hub.docker.com/) вы должны увидеть новый образ в репозитории "qrcode". 

20. Выполним окончательную настройку данного job-a, а именно настроем триггер, который будет следить за изменениями в репозитории на GitHub.

21. В разделе "Build Triggers"  выберите и настройте "Poll SCM" или "GitHub hook trigger for GITScm polling" по своему усмотрению.

22. Для проверки работоспособности job-a. Замените содержимое файл "main.py" в локальном репозитории на следующее:

    ```python
    import qrcode
    import base64
    from flask import Flask
    from flask import request
    from io import BytesIO
    
    app = Flask(__name__)
    
    @app.route("/")
    def root():
       return '''<form action="/qr" method="GET">
          <input type="text" name="msg" placeholder="Enter text"/>
          <input type="submit" value="QR-code"/>
       </form>'''
    
    
    @app.route("/qr")
    def qr():
       msg = request.args.get('msg')
       img = qrcode.make(msg)
       
       buffer = BytesIO()
       img.save(buffer, format="png")
     
       img64 = base64.b64encode(buffer.getvalue())
       return f'<img src="data:image/png;base64, {img64.decode()}" alt="qrcode" />'
    
    
    if __name__ == "__main__":
       app.run(host='0.0.0.0')
    ```

23. Выполните коммит, пуш на GitHub и убедитесь, что через некоторое время на [DockerHub](https://hub.docker.com/) появилась свежая версия приложения.

### Автоматизация деплоя

Здесь мы настроим процесс автоматического запуска job-а при обнаружении изменений в GitHub-репозитории, и передачи содержимого репозитория на другой сервер по ssh. Для простоты пропустим этапы сборки тестирования и т.д.

1. Для начала установим плагин, который позволит передавать файлы с сервера Jenkins на другие сервера.

   - Выберите в меню слева пункт "Настроить Jenkins" ("Manage Jenkins"), а затем "Управление плагинами" ("Manage Plugins");

   - После этого меню слева переключится в режим управления плагинами. Выберите пункт "Доступные плагины" ("Available plugins") и в строку поиска вбейте "Publish Over SSH";

   - Поставьте галочку рядом с "Publish Over SSH" и нажмите кнопку "Download now and install after restart". Плагин проверит зависимости и через некоторое время начнёт установку.

   - В самом низу поставьте галочку "Перезапустить Jenkins по окончанию установки и отсутствии активных задач". Вкладка может не обновится автоматически, поэтому обновите её вручную через некоторое время.

2. Теперь нужно добавить машины на которые мы собираемся выполнять "деплой".

   1. Запустите сервер который вы настраивали в процессе выполнения работы №1;
   2. Перейдите в web-интерфейс Jenkins и выберите в меню слева пункт "Настроить Jenkins" ("Manage Jenkins"), а затем "Конфигурация системы" ("Configure System");
   3. Промотайте страницу почли до самого конца до радела "Publish over SSH" и здесь найдите подраздел "SSH Servers";
   4. В поле "Name" напишите любое имя, оно будет отображаться в списках выбора серверов;
   5. В поле "Hostname" укажите ip-адрес сервера, который вы настраивали для работы №1;
   6. В поле "Username" укажите proger. Этого пользователя вы должны были создать в процессе выполнения работы №1. Ему разрешено заходить с любых ip-адресов и авторизоваться по паролю.
   7. В этом же блоке, чуть ниже разверните подраздел "Advanced" и в поле "Port" введите тот порт, который вы указывали в файле "/etc/ssh/sshd_config" в работе №1 (у меня это был 6543).
      ![](./task_02_img/ssh_servers.png)
   8. Нажмите кнопку "Save" и перейдите обратно на главную страницу.

3. Создайте новый job типа "Freestyle project".

4. В разделе "Source Code Management" укажите те же настройки, что и ранее.

5. В разделе "Build Triggers"  выберите и настройте "Poll SCM" или "GitHub hook trigger for GITScm polling" по своему усмотрению.

6. В разделе "Build Steps" на этот раз ничего добавлять не будем. Обычно здесь выполняется сборка, тестирование и т.д.

7. В разделе "Post-build Actions" щёлкните по кнопке "Add post-build action" и в раскрывшемся списке выберете "Send build artifacts over SSH".

8. Теперь нужно настроить процесс пересылки файлов на целевую машину:

   - В разделе "SSH Server" в поле "Name" у вас будет автоматически выбран тот сервер который мы только что добавили, т.к. он единственный.
   - Нажмите по кнопке "Advanced" и поставьте галочку на против "Credentials". Как результат развернётся подраздел настройки доступа к серверу. Здесь доступны настройки как по ключу, так и по паролю. В этой работе, для простоты, воспользуемся вариантом доступа по паролю.
   - Введите в поле "Username" имя пользователя (у меня это proger), а в поле "Passphrase / Password" введите пароль. Убедитесь, что всё правильно, при помощи кнопки "Test Configuration".  
     ![](./task_02_img/serv_acsses.png)
   - Ниже в разделе "Transfers" указывается что и куда будет пересылаться. Мы будем пересылать только файлы "main.py" и "requirements.txt", которые попадут в рабочую директорию Jenkins из репозитория в папку "app" расположенную в домашней директорию пользователя proger.  
     Для этого введите в "Source files" список файлов через запятую: main.py, requirements.txt. В поле "Remote directory" введите: app. Остальные поля можно не заполнять.  
     ![](./task_02_img/transfer.png)

9. Сохраните настройки job-а.

10. Внесите любые изменения в удалённый репозиторий, чтобы активировать триггер.

11. Проверьте, что job отработал и файлы с GitHub действительно скопированы в каталог app расположенный в домашней директории пользователя proger.

## Полезные ссылки

1. [Курс Основы Jenkins на Русском для Девопс Инженеров](https://youtube.com/playlist?list=PLg5SS_4L6LYvQbMrSuOjTL1HOiDhUE_5a) - набор видео-роликов демонстрирующих основные операции по работе с Jenkins.

## Вопросы к практическому заданию

1. Какой стандартный порт который прослушивает Jenkins?;
2. Из какой переменной окружения можно узнать путь к рабочему каталогу данного job-a?
3. Какой триггер нужно использовать, чтобы настроить запуск job-a по понедельникам в 3 часа ночи?
4. Каким образом из Jenkins можно удалить установленный плагин?
5. Где в Jenkins лучше хранить секреты: пароли/токены/ключи с точки зрения безопасности?

## Отчёт

Оформите отчёт в соответствии с шаблоном и загрузите его в элемент Задание с номером работы в мудле.

