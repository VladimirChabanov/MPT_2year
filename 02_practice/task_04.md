# Практическое задание 4. Docker.

**Цель:** ознакомится с базовыми возможностями Docker.

## Задания к практической работе

Каждую выполненную вами команду и результат её работы поместите в отчёт в виде скриншота (начиная с пункта Контейнеризация). Если несколько команд и их выводы видны на одном скриншоте, в отчет можно вставить 1 скриншот на несколько команд. Команды остановки и удаления контейнеров тоже можно не помещать в отчёт.

### Настройка базового Flask приложения

Сначала мы создадим простое Flask приложение, просто для того, чтобы было что положить в Docker контейнер.

1. Откройте терминал: <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>T</kbd> (Ubuntu). Терминал откроется в домашнем каталоге пользователя (`/home/user/`);

2. Создайте каталог `tutorial` и зайдите в него: `mkdir tutorial && cd tutorial`;

3. Теперь создайте каталог `flask` и зайдите в него: `mkdir flask && cd flask`.  Тут будет flask-приложение;

4. Создайте виртуальное окружение с именем ven: `python3 -m venv venv`.  
Виртуальное окружение позволит изолировать разные проекты друг от друга и содержать в "чистоте" глобальное окружение.

5. Активируйте  виртуальное окружение: `source venv/bin/activate`;  
Если всё правильно, то в начале строки появится название виртуального окружения. Например такое: `(venv) user@user-pc:~/tutorial/flask$`;

6. Установите пакет Flask с помощью pip : `pip install Flask`;

7. Создайте файл с именем `app.py`. 

     - например, так: `touch app.py` - пустой файл. В дальнейшем можно открыть графическим текстовым редактором;

     - или так: `nano app.py`. Будет создан файл и открыт в консольном текстовом редакторе;

8. Скопируйте в `app.py` код из документации Flask для создания базового приложения:

  ```python
  from flask import Flask

  app = Flask(__name__)

  @app.route('/')
  def hello_world():
       return 'Hello, World!'

  if __name__ == "__main__":
       app.run(debug=True, host='0.0.0.0')
  ```

9. Запустите `python app.py` и вы должны увидеть запуск сервера.  
    Вы можете проверить работу сервера обратившись к нему по URL: http://localhost:5000 (например через браузер или в новом окне терминала `curl http://localhost:5000`. Вы должны увидеть "Hello, World!");

10. Остановите сервер комбинацией клавиш: <kbd>Ctrl</kbd>+<kbd>C</kbd>;

11. Сохраните установленные пакеты (зависимости) в файл `requirement.txt`: `pip freeze > requirement.txt`. В дальнейшем мы будем использовать его для установки нужных пакетов.

    > Если в созданном файле появится строка `pkg-resources==0.0.0` удалите её.

12. Далее можно деактивировать виртуальное окружение командой: `deactivate`.  В принципе можно и не деактивировать, разницы нет. Мы будем работать с docker, а он ничего не знает о виртуальных окружениях, созданных командой `venv`.

### Контейнеризация

Чтобы продолжить вам нужен установленный Docker. Так же желательно ознакомиться с тем [что такое Docker](https://habr.com/ru/company/ruvds/blog/438796/) и базовым набором команд [Dockerfile](https://habr.com/ru/company/ruvds/blog/439980/)-а.

#### 1. Создаём Dockerfile

С базовым набором команд Dockerfile можно ознакомится в [посте на хабре](https://habr.com/ru/company/ruvds/blog/439980/), с более полной версией в [документации](https://docs.docker.com/engine/reference/builder/).

Теперь, когда у нас есть приложение, упакуем его. Как основу для нашего будущего Docker-образа будем использовать другой образ, с установленным интерпретатором Python версии 3.7 (просто, чтобы не делать этого самим).

Сначала мы напишем инструкцию (`Dockerfile`), следуя которой Docker будет собирать новый образ.

В данный момент мы всё ещё находимся в директории `flask`. Можете проверить это при помощи команды `pwd` (вы должны увидеть что-то вроде этого: `/home/user/tutorial/flask`).

- Создайте файл с именем `Dockerfile` (`nano Dockerfile`) и скопируйте в него приведенный ниже код:

  ```docker
  FROM python:3.7
  WORKDIR /app
  COPY . /app
  RUN pip install -r requirement.txt
  ENTRYPOINT [ "python" ]
  CMD [ "app.py" ]
  ```

- В строке `FROM python 3.7` мы используем официальный образ python 3.7, доступный на [dockerhub](https://hub.docker.com/layers/python/library/python/3.7/images/sha256-fbd08545ac394bb3c086f191960a1f3e1d6f148ec62c956ad97150f36d0c87ac?context=explore);

- Командой `WORKDIR /app` мы создаем каталог внутри контейнера с именем `app` и назначаем его рабочей директорией.

- Затем копируем все файлы из текущего каталога  в каталог `/app` внутри контейнера. Обратите внимание, что у команды `COPY` два аргумента `.` - текущая директория локального контекста и `/app` - директория внутри контейнера; 

- Далее мы используем `RUN` для установки зависимостей, перечисленных в `requirement.txt` при помощи `pip`;  

Команды выше будут выполнены один раз, в процесс сборки образа.

- Последние две строки указывают, что при каждом запуске контейнера будет запущена команда `python` с аргументом `app.py`.

#### 2. Создаём образ

Когда Dockerfile готов приступаем к созданию образа. В упрощённом смысле происходит скачивание виртуальной машины (c [dockerhub](https://hub.docker.com/)), в которой установлена операционная система на базе Linux (может быть и Windows), а также некоторые дополнительные программы (в нашем случае Python). Затем происходит копирование на диск виртуальной машины (в каталог `/app`) содержимого текущего каталога ( в нашем случае мы находимся в `flask`) и установка зависимостей из `requirement.txt`. Получившийся образ сохраняется на локальный диск.

Запустим сборку образа:

- `docker build -t flask .`

> При выполнении приведенной выше команды убедитесь, что вы находитесь в каталоге `flask`, т.к. символ `.` означает, что Docker должен попытается найти файл с именем `Dockerfile` в текущем каталоге.

> Флаг `-t` с параметром `flask` означает, что у созданного образа будет имя `flask` (при желании можно добавить тег, например для указания версии образа: `flask:1.0`. Тег по умолчанию `latest`).

После того, как сборка образа завершилась введите:

- `docker image ls` или `docker images`

В списке локальных образов вы должны увидеть что-то вроде этого:

```
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
flask        latest    3444af10689c   4 minutes ago   928MB
python       3.7       dd540b53e812   3 days ago      906MB
```

Наш образ `flask:latest` и его родительский образ `python:3.7`.

Может быть, что процесс сборки будет прерван из-за ошибки, и в списке появятся ещё несколько "не доделанных" образов. В этом случае их следует удалить используя команду: `docker rmi` с указанием `IMAGE ID` удаляемого образа (возможно потребуется добавить ключ `-f`).

#### 3. Запускаем контейнера

Вы успешно создали образ, и теперь наше приложение готово к запуску. Используйте `docker run` для запуска контейнера:

- `docker run flask`

Из образа `flask` будет создан новый контейнер, который, в свою очередь, будет запущен.

> Нужно различать понятия **образа** и **контейнер**. Образ (который мы создавали по Dockerfile-у) является шаблоном на основании которого создаются контейнеры, а контейнеры - это конкретные виртуальные машины (при запуске все одинаковые), работающие независимо друг от друга. Одновременно можно запускать несколько контейнеров.

> По умолчанию, контейнеры, как и остальные программы, запускаются на переднем плане (attached mode), поэтому, чтобы выполнять другие команды придётся открыть новое окно терминала.

> Если запустить контейнер из образа которого нет на локальном компьютере, то Docker попробует найти его на dockerhub и скачать. Например, выполните команду `docker run hello-world`, а затем проверьте список образов.

> Если вы не указываете тег образа, то по умолчанию используется тег `latest`. Например: `docker run python` на самом деле `docker run python:latest`. Как мы видели ранее у нас в списке только `python:3.7`, поэтому он НЕ будет запущен, а будет скачан и запущен образ `python:latest`.

Откройте новое окно терминала и посмотрите список **запущенных** контейнеров с помощью команды:

- `docker ps` или `docker container ls`

Вы увидите идентификаторы работающих контейнеров, их имена, статусы и т.д...

```
CONTAINER ID   IMAGE     COMMAND           CREATED              STATUS          PORTS     NAMES
d9990d04da9e   flask     "python app.py"   About a minute ago   Up 36 seconds             quizzical_mahavira
```

Вернитесь в терминал с запущенным контейнером и завершите его работу нажав <kbd>Ctrl</kbd>+<kbd>C</kbd>.

Запустите новый контейнер с ключом `-d`:

- `docker run -d flask`

теперь он будет запущен в фоновом режиме (detached mode) и терминал останется не заблокирован. Сочетание клавиш <kbd>Ctrl</kbd>+<kbd>C</kbd> уже не приведёт к завершению работы контейнера. Во время запуска в терминале был напечатан `CONTAINER ID` его можно использовать для остановки контейнера.  
> Hе обязательно переписывать весь `CONTAINER ID`, можно ограничиться несколькими начальными символами. Главное, чтобы Docker мог отличить нужный вам контейнер от других.

Выполните команду:

- `docker stop <CONTAINER_ID>`

Есть ещё интерактивный режим запуска (ключи `-it`). То есть, после создания контейнера поток ввода нашего терминала перенаправляется внутрь контейнера, а поток вывода из контейнера перенаправляется нам в терминал.

Посмотрим это на примере контейнера построенного из образа python:3.7 (он у нас уже есть):

- `sudo docker run -it python:3.7`

Внутри созданного контейнера будет запущен интерпретатор Python, но мы можем работать с ним так, как будто запустили интерпретатор у себя в терминале.  
Попробуйте ввести несколько команд на Python, чтобы убедится в этом, а затем введите `exit()` чтобы выйти из интерпретатора. Заметьте, что при этом контейнер тоже завершил работу.

> Причина в том, что Docker-контейнер работает, пока работает программа указанная в нём для запуска и останавливается, как только запущенный процесс заканчивает работу/падает с ошибкой/прерывается пользователем.  
В нашем Dockerfile, для образа `flask`, в качестве такой программы был назначен интерпретатор Python (`ENTRYPOINT [ "python" ]`) c аргументов `app.py` (`CMD [ "app.py" ]`). Поэтому, когда мы прерывали работу скрипта `app.py` (при помощи <kbd>Ctrl</kbd>+<kbd>C</kbd>) контейнер тоже останавливался.

Запустите новый контейнер `flask` в фоновом режиме (ключ `-d`), а затем введите команду:

- `docker exec -it <CONTAINER_ID> bash`

`CONTAINER_ID` был напечатан в терминале во время запуска контейнера.

Команда `docker exec` позволяет подключится к запущенному контейнеру и выполнить в нём указанную команду (здесь это запуск `bash`). Попробуйте использовать `ls`, чтобы убедиться, что в контейнере находятся файлы скопированные из каталога `flask`. (Также обратите внимание, что по умолчанию мы попадаем в каталог `/app`, потому что мы установили его командой `WORKDIR` в Dockerfile).

Помните, что наше приложение работает на порту 5000? Давайте попробуем обратиться к серверу, как мы делали это ранее. Через браузер по URL http://localhost:5000 или при помощи команды: `curl http://localhost:5000` (но только из другого окна терминала).

Что, не работает? На самом деле так и было задумано.

> Наше приложение действительно работает на localhost:5000, но только внутри контейнера. Вы можете проверить журнал контейнера (`docker logs <CONTAINER_ID>`) или использовать curl изнутри контейнера (из терминала в котором была выполнена команда `docker exec`), он будет работать.

> Причина в том, что, по умолчанию, контейнеры не подключены к сети хост-машины, они подключаются к своей изолированной сети (подробнее об этом далее).

Мы можем попросить Docker перенаправить http-трафик с нашего localhost:5000 на порт 5000 в запущенном контейнере. Для этого можно использовать опцию `-p` (от слова port).

Остановите запущенный ранее контейнер и запустите новый, командой:

- `docker run -dp 5000:5000 flask`

> Опция `-d` (объединенная здесь с опцией `-p`) означает запуск контейнера в фоновом режиме; опция `-p` означает проброс портов, первый из которых - это порт на хост-машине (ваш компьютер), а второй - порт в контейнере.

> Порты не обязаны быть одинаковыми. Например 1234:5000 - проброс порта 1234 на хост-машине на порт 5000 в контейнере.

> Для проброса нескольких портов повторите комбинацию `-p <host_port>:<container_port>` для каждой пары портов.

> Т.к. один порт может прослушиваться только одним процессом, то для запуска нескольких контейнеров, нужно указать разные порты хост-системы, например:
> 
> ```
> docker run -dp 5000:5000 flask
> docker run -dp 4000:5000 flask
> ```
>
> или так:
>
> ```
> docker run -dp 5000 flask
> ```
> 
> В последнем варианте явно указывается только порт в контейнере, а на хост-системе будет выбран случайный свободный.
> 
> Чтобы узнать какой именно порт был назначен можно воспользоваться командой:
>
> ```
> docker port <CONTAINER_ID>
> docker port <CONTAINER_ID> 5000
> ```
> 
> В первом варианте будут показаны все проброшенные порты, во втором только указанный.

Попробуйте сейчас перейти по URL: http://localhost:5000!

Остановите контейнер.

Запустите 2 новых контейнера:

```
docker run --name=my_name -d flask
docker run -d flask
```

Выполните команду `docker ps` и обратите внимание на столбец `NAMES`.

> Ключ `--name` позволяет задать имя контейнера вручную. Если этого не сделать, то Docker сгенерирует случайное человекочитаемое имя. Вместо `=` можно использовать пробел.

> Имя контейнера можно использовать во всех командах вместо CONTAINER_ID, поэтому оно так же должно быть уникальным.

> В командах имя контейнера нужно указывать полностью (в отличие от CONTAINER_ID), но т.к. автодополнение работает для имён (<kbd>Tab</kbd>) это не создаёт проблем.

Остановите все запущенные контейнеры и наберите команду:

- `docker container ls -a` или `docker ps -a`

Вы увидите список всех контейнеров. Несмотря на то, что на данный момент ни один из них не запущен они всё ещё хранятся и занимают место на диске. Удалить их можно командой:

- `sudo docker rm <CONTAINER_ID>`

или 

- `sudo docker container prune`

чтобы удалить все остановленные контейнеры.

> Если запустить контейнер с ключом `--rm`, то он будет автоматически удалён после остановки.

#### 4. Уменьшаем размер образа

Определите размер образа `flask` используя `docker image ls`.

Святая корова, он тяжелый! Что-то около 900 МБ для python, работающего с приложением Flask? Давайте изменим это.

У нас есть 2 основных способа уменьшить вес образа.

1. Файлы.

Когда вы ранее запускали `ls` в `/app` внутри контейнера, заметили ли вы, что там был каталог `venv`, а также файл `Dockerfile`? В контейнере приложению не нужен `Dockerfile` (он нужен только для сборки образа), а зависимости устанавливаются при помощи pip в глобальное окружение контейнера, поэтому и каталог `venv` тоже не используется (то есть образ содержит зависимости дважды). Нужно как-то не допустить попадания "мусорных" файлов в образ.

У этой задачи есть 2 возможных решения:

- Во-первых, мы можем изменить файл `Dockerfile` и скопировать не все файлы из директории flask, а только те, которые нужны. У нас очень маленькое приложение, и оно простое, но для больших проектов это может занять довольно много строк.

- 2-й вариант: Docker предоставляет нам возможность добавить файл `.dockerignore`, который работает как файл `.gitignore`. Когда Docker запустит `COPY . /app` при создании образа он НЕ будет копировать файлы или каталоги перечисленные в `.dockerignore`.

Создайте в каталоге `flask` файл `.dockerignore` содержащий:

```
ven/
Dockerfile
```

> Чтобы убедится, что файл создан наберите команду `ls -a`. Без ключа `-a` файлы начинающиеся с точки вы не увидите (по умолчанию они скрыты).

Пересоберите образ командой `docker build`, но назовите его `flask:clean`.  

> clean - это тег. Просто, чтобы иметь возможность отличить новый образ от старого. Если тег не указать, то будет установлено значение по умолчанию latest и новый образ затрёт старый.

Проверьте список образов и сравните размеры `clean` и `latest`.

2. Базовый образ.

В качестве базового образа мы использовали образ построенный на ubuntu. То есть полновесная ubuntu! Чтобы просто запустить Flask-приложение!! Есть много функций ubuntu, которые нам не нужны. Возможно, нам удастся найти более легкий дистрибутив Linux для запуска нашего приложения. Один из самых популярных - `alpine`. При этом, нам даже не придётся выполнять установку интерпретатора самостоятельно, в реестре python в [dockerhub есть образ](https://hub.docker.com/layers/python/library/python/3.7-alpine3.12/images/sha256-0d124bf8fdfe7bfd5835187da5481b76a012b52571cef1a2b2c0e5029080d4dc?context=explore), основанный на `alpine`!

Откройте `Dockerfile` и замените первую строку на:

- `FROM python:3.7-alpine3.12`

Пересоберите образ командой `docker build` и назовите его `flask:min`.

Запустите `docker image ls`. Новый образ должен весить что-то около 50 МБ. Всё еще немного великовато, но пока на этом остановимся.

Удалите образы `flask` c тегами `latest`, `clean` и образ `python` с тего `3.7`:

- `docker rmi flask:latest flask:clean python:3.7`

Как упоминалось выше, если мы сейчас попробуем выполнить `docker run flask`, то получим ошибку, т.к. у нас нет образа `flask:latest` и с dockerhub его тоже скачать не получается. Следовательно, во всех командах придётся писать `flask:min`, что не всегда удобно. Исправим это.

Выполните команды:

```
docker image tag flask:min flask:latest
docker image tag flask:min my_app:latest
docker image ls
```

и обратите внимание на `IMAGE ID`

```
REPOSITORY    TAG              IMAGE ID       CREATED         SIZE
flask         latest           6fe5cf335649   21 hours ago    53.8MB
flask         min              6fe5cf335649   21 hours ago    53.8MB
my_app        latest           6fe5cf335649   21 hours ago    53.8MB
hello-world   latest           feb5d9fea6a5   8 months ago    13.3kB
python        3.7-alpine3.12   0d662e96b1e5   12 months ago   42.2MB
```

Предыдущей командой мы добавили 2 других имени для образа с нашим приложением.

Удалите `my_app:latest` и `flask:min` командой `docker rmi`. При этом удалятся только имена, а сам образ останется под именем `flask:latest`.

#### 5. Взаимодействие контейнеров

##### 5.1 Сетевое взаимодействие

Перед выполнением рекомендуется ознакомится с [этим](https://itisgood.ru/2019/10/29/objasnenie-koncepcii-setej-v-docker/) постом.

Самым распространённым способом взаимодействия контейнеров - это обмен данными через сеть. Docker позволяет создавать разные типы сетей, но мы рассмотрим только `bridge` и `host`.

Для начала проверьте какие сети уже созданы:

- `docker network ls`

Вы должны получить что-то вроде этого:

```
NETWORK ID     NAME               DRIVER    SCOPE
b4dad78c9e66   bridge             bridge    local
8c8110ea3bd3   host               host      local
936056c7c16b   none               null      local
```

Запустите контейнер `flask` командой:

- `docker run -d --network=host flask`

Попробуйте послать запрос на http://127.0.0.1:5000. Как вы увидите, всё будет работать, несмотря на то, что мы не пробрасывали порты.

> Ключ `--network` позволяет подключить контейнер к указанной сети по имени или `NETWORK ID`.

> В последней команде мы использовали сеть с именем `host` и одноимённым драйвером. Драйвер `host` подключает контейнер к сети хост-машины, то есть, с точки зрения сети, нет разницы между приложением, запущенным в контейнере и просто на хост-машине. Они не изолированы друг от друга и могут взаимодействовать без дополнительных телодвижений. Если мы попробуем запустить второй `flask` контейнер с `--network host` он упадёт с ошибкой, т.к. порт 5000 уже занят.

> При подключении к `host` сети проброс портов игнорируется (т.к. порты контейнера итак соединены с портами хост-машины), а во время запуска будет показано соответствующее предупреждение.

Остановите контейнер, запустите новый обычным образом, без указания сети:

- `docker run -d --name=one flask`

Выполните внутри контейнера `one` команду `ip a`

- `docker exec one ip a`

> Команда `ip` покажет сетевые интерфейсы и IP адреса присвоенные им. А ключ `a` означает - все.

В моём случае вывод такой:

```
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
89: eth0@if90: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP 
    link/ether 02:42:ac:11:00:07 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.6/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
```

Как видно, кроме `127.0.0.1` есть интерфейс с IP адресом `172.17.0.6`.

Запустите ещё один контейнер. И выполните те же действия, что и с первым:

```
docker run -d --name=two flask
docker exec two ip a
```

В моём случае IP адрес `172.17.0.7`.

Похоже, что эти контейнеры находятся в одной сети. Проверим это при помощи команды `ping`. Пропингуем из первого контейнера второй:

- `docker exec one ping 172.17.0.7`

Так и есть, пинги идут.

> Контейнеры, запущенные без явного указания сети, подключаются к одной сети (она задана в настройках по умолчанию). В нашем случае это сеть `bridge`, с одноимённым драйвером.

> Сеть с драйвером `bridge` - это просто отдельная сеть, которую можно использовать для соединения контейнеров.

> Драйвер `null` (сеть `none`) используется если контейнер нужно изолировать от сетевых подключений вообще. Проброс портов тоже работать не будет.

При подключении к сети, контейнеры получают IP адрес динамически, что затрудняет настройку их взаимодействия.

> Вообще говоря, можно задать фиксированный IP или свободный из диапазона. 

Какие есть решения этой проблемы:

1. Использовать `--link`;

Ключ `--link` на данный момент считается устаревшим, поэтому не будем посвящать ему много времени.

Данный ключ позволяет во время запуска контейнера подключить его к другим. Подключение состоит в том, что в запускаемый контейнер будет добавлен ряд переменных окружения и в его файл `/etc/hosts` будет добавлена новая запись (для каждого из подключаемых контейнеров). При этом, в тех контейнерах, к которым мы подключаемся никаких изменений не будет.

Запустите новый контейнер:

- `sudo docker run -d --name=three --link=one --link=two:alias_for_two flask`

> Здесь мы подключаем контейнер `three` к контейнерам `one` и `two`. При этом контейнер `one`, внутри контейнера `three`, будет виден под именем `one`, а контейнера `two` ещё и под именем `alias_for_two`.

Получите список переменных окружения контейнера `three`:

- `docker exec three env`

> Вы увидите множество переменных начинающихся с `ONE` и `ALIAS_FOR_TWO`.

Посмотрите содержимое файла `/etc/hosts`:

- `docker exec three cat /etc/hosts`

Вывод должен быть похож на этот:

```
127.0.0.1 localhost
::1 localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.17.0.6  one bb21bfc5429e
172.17.0.7  alias_to_two 02ed683a2ce3 two
172.17.0.8  15d2a9a855b6
```

> Как видно в последних строках к IP адресам привязаны доменные имена. Это значит, что можно писать код/конфиги привязываясь к именам контейнров, а не IP адресам.

Проверьте, что `ping` по имени контейнера работает: 

- `docker exec three ping one`

При этом, в обратном направлении работать не будет:

- `docker exec one ping three`

Остановите и удлалите все контейнеры.

2. Использовать имя контейнера и свою сеть;

Дальнейшее работает только с сетями создаными пользователем.

Для начала создадим новую сеть:

- `docker network create sky_net`

> Сети, созданные без указания драйвера имеют тип `bridge`

> Удалить сеть можно командой: `docker network rm sky_net`

Запустите контейнер командой:

- `docker run -d --name=one --network=sky_net flask`

Данный контейнер сразу же подключится к сети `sky_net`.

> Команда `--network` позволяет подключится только к одной сети.

Запустите второй контейнер обычным способом:

- `docker run -d --name=two flask`

а затем подключите его к сети `sky_net`

- `docker network connect sky_net two`

> Таким образом можно подключить контейнер к любому числу сетей.

> Отключить контейнер можно командой: `docker network disconnect sky_net two`

Попробуйте пропинговать контейнеры по их именам:

```
docker exec one ping two
docker exec two ping one
```

Как видите, работает в обе стороны.

> В данном случае никаких изменений в `hosts` или переменных окружения не происходит. Маршрутизация осуществляется при помощи отдельного DNS, который Docker добавляет к каждой созданной пользователем сети.

Введите команду:

- `docker network inspect sky_net`

В разделе `"Containers"` можно посмотреть список всех подключённых к сети контейнеров.

3. Использовать сетевой псевдоним и свою сеть.

При подключении к сети можно указать дополнительное доменное имя под которым контейнер будет виден в сети:

- `docker run -d --name=three --network=sky_net --network-alias=other flask`

или

- `docker network connect --alias=other sky_net three`

если контейнер подключается к сети после запуска.

Остановите контейнеры.

##### 5.2 База данных MySQL в контейнере

Наше приложение для хранения данных будет использовать базу данных `mysql`.

Никаких дополнений к контейнеру мы делать не будем, поэтому `Dockerfile` нам не нужен, просто скачаем с dockerhub [последнюю версию](https://hub.docker.com/_/mysql?tab=description):

- `docker pull mysql`

> В нашем случае можно было не скачивать образ отдельной командой, а сразу запустить контейнер, он бы скачался автоматически (как мы и делали ранее).

Запустим контейнер с сервером Mysql, как указано на странице образа на dockerhub:

- `docker run -d --name=my_db -e MYSQL_ROOT_PASSWORD=123 mysql`

> Ключ `-e` позволяет добавить переменные среды в контейнер. В данном случае переменная `MYSQL_ROOT_PASSWORD` устанавливает пароль для пользователя `root` в значение `123`.

> К серверу в контейнере можно подключиться двумя способами (не считая заход внутрь контейнера):

1. Любым Mysql клиентом <u>установленным</u> локально на хост-машине или удалённо. Но для этого нужно либо запустить контейнер с параметром `--network=host` или пробросить порт 3306 (стандартный порт для сервера mysql).

> Если изучить страницу образа, то можно найти там строку `EXPOSE 3306 33060`. Данная команда (используется в Dockerfile) позволяет пробросить указанные порты автоматически, если при старте контейнера указать `-P`. На хост-машине будут выбраны случайные порты.  
> Для нашего `flask`-приложения мы могли бы добавить в Dockerfile строку `EXPOSE 5000`

2. Клиентом находящимся в другом контейнере. Такой клиент уже присутствует в скачанном нами образе. Так и поступим.

Для удобства создайте новую сеть:

- `docker network create tutorial`

и подключите к ней mysql-сервер:

- `docker network connect tutorial my_db`

затем выполните команду, для подключения клиента:

- `docker run -it --network=tutorial mysql mysql -hmy_db -uroot -p123`

> Первая часть команды (`docker run -it --network=tutorial mysql`) запускает контейнер `mysql` в интерактивном режиме и подключает его к сети `tutorial`. Вторая часть (`mysql -hmy_db -uroot -p123`) это команда, которую нужно выполнить в запущенном контейнере (она не относится к докеру). 
>
> Т.е. в контейнере мы запускаем утилиту `mysql` с ключами `-h`, `-u`, `-p`.
>
> - `-h` - это хост или IP-адрес сервера, к которому нужно подключится (у нас он совпадает с именем контейнера запущенного ранее `my_db`);
> - `-u` - имя пользователя под которым мы подключаемся к базе данных (у нас это `root`);
> - `-p` - пароль (не путайте с пробросом портов) у нас это `123`, мы установили его при запуске сервера.

Если вы всё сделали правильно, то увидите приглашение к вводу команд `mysql`.

Выполним несколько команд. Для начала посмотрим какие базы данных уже существуют:

- `SHOW DATABASES;`

Создайте новую базу данных и снова проверьте список:

- `CREATE DATABASE test;`

> Если остановить контейнер с базой данных `docker stop`, а затем снова его запустить `docker start`, то данные потеряны не будут.  
> Если удалить контейнер, то вместе с ним будут удалены и все данные, которые в нём хранились (разумеется и база данных тоже).

Остановите и удалите контейнеры с клиентом и сервером `mysql`.

##### 5.3 Работа с данными

Перед выполнением рекомендуется ознакомится с [этим](https://habr.com/ru/company/ruvds/blog/441574/) постом.

Данные в Docker могут храниться либо временно, либо постоянно. 

По умолчанию файлы, создаваемые приложением, работающим в контейнере, сохраняются в слое контейнера, поддерживающем запись. Для того чтобы этот механизм работал, ничего специально настраивать не нужно. Приложению достаточно просто сохранить данные и продолжить заниматься своими делами. Однако после того как контейнер перестанет существовать, исчезнут и данные, сохранённые таким вот нехитрым способом.

Но не волнуйтесь, Docker позволяет работать с данными и другим образом. При помощи томов (volume) и монтирования каталогов внутрь контейнера (bind mount).

1. Монтирование каталога внутрь контейнера [(bind mount)](https://docs.docker.com/storage/bind-mounts/).

Выйдите из каталога `flask` обратно в `tutorial` и запустите новый контейнер `mysql` командой:

- `docker run -d --name=my_db -v "$(pwd)"/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123 mysql`

> Ключ `-v` позволяет монтировать каталоги или тома к контейнеру. После ключа `-v` нужно указать `<путь к каталогу на хост-машине>:<путь к каталогу внутри контейнера>`. Важно, то что пути должны быть абсолютные. В нашем случае, конструкция `"$(pwd)"` развернётся в полный путь к папке `tutorial` т.к. мы находимся в ней во время запуска контейнера.

Перейдите в каталог `mysql` и посмотрите его содержимое.

> Во-первых, т.к. каталога `mysql` в `tutorial` не существовало на момент монтирования, он был создан автоматически. Тоже произойдёт, если указать не существующий каталог внутри контейнера.

> Во-вторых, каталог `mysql` содержит множество файлов и папок (база данных + настройки), которые были созданы в контейнере, но видны как в самом контейнере, так и в хост-системе.

> В-третьих, созданные файлы и сам каталог `mysql`  принадлежит пользователю `root`, что совсем не хорошо.

> При старте, содержимое монтируемого каталога будет скопировано внутрь контейнера (в указанную папку), поэтому, если даже мы остановим и удалим текущий контейнер, мы всегда сможем создать новый и подключить к нему папку с нашей базой данных.  
> Учтите, что при монтировании содержимое каталога не добавляется в контейнер, а происходит замена. Например, если запустить наш контейнер `flask` и примонтировать к нему пустой каталог (`-v "$(pwd)"/empty_dir:/app`), то он упадёт с ошибкой, т.к. стартовая команда попытается запустить файл `app.py`, но не сможет его найти, т.к. теперь, каталог `/app` в контейнере пуст.

Ключ `-v` на данный момент считается устаревшим и как альтернативу можно использовать ключ `--mount`. В этом случае нужно заменить:

```
-v "$(pwd)"/mysql:/var/lib/mysql
--mount type=bind,source="$(pwd)"/mysql,target=/var/lib/mysql
```

2. Монтирование томов [(volumes)](https://docs.docker.com/storage/volumes/).

По умолчанию, если запустить `mysql` без монтирования каталога, будет создан том, в котором и будет хранится база данных.

Для начала посмотрите список созданных томов:

- `docker volume ls`

В списке вы должны увидеть, как минимум один том (он был создан при первом запуске `mysql` сервера).

Создайте новый том:

- `docker volume create data` - имя тома `data`.

> Можно и так `sudo docker volume create`, но тогда имя выбирается случайно.

Запустите ещё один контейнер с `mysql` и подмонтируйте к нему том `data`.

> Если во время запуска указать не существующий том, он тоже будет создан  
> `-v volume_name:/app`  
> `--mount type=volume,source=volume_name,target=/app`

Удалить том можно командой:

- `sudo docker volume rm volume_name` - имя нужно указывать полностью
- `sudo docker volume prune` - удалить все тома

Посмотреть информацию о томе можно командой:

- `sudo docker volume inspect volume_name`

В остальном работа с томами мало чем отличается от работы с каталогами, но использование томов считается лучшим решением, т.к. работа тома обеспечивается самим Docker и не привязана к файловой системе хост-машины.

Каталоги и тома можно монтировать к нескольким контейнерам одновременно и, при желании, выполнять обмен данными, через них.

Остановите и удалите созданные контейнеры.

#### 6. Создание образа из контейнера

Обычно мы действуем по обратному сценарию, т.е. из образа создаём контейнеры, но иногда проще внести изменения в готовый контейнер и сделать из него образ, чем писать с нуля Dockerfile.

Мы будем вносить изменения в контейнер `flask`.

Запустите новый контейнер в фоновом режиме:

- `docker run -d --name=flask_base flask`

Установим в этом контейнере модуль для работы с mysql - `mysql-connector-python`:

- `docker exec flask_base pip install mysql-connector-python`

Остановите контейнер:

- `docker stop flask_base`

Теперь изменим скрипт, расположенный в контейнере в файле `app.py`. Для этого скопируем данный файл из контейнера на диск в хост-системе:

- `docker cp flask_base:/app/app.py .`

> В принципе, в нашем случае, это можно и не делать, т.к. мы будем менять файл полностью. Но для полноты описания, пусть будет.
> Первый аргумент это <имя или id контейнера>:<путь к файлу>, второй - это путь к каталогу, в который будет скопирован файл (в нашем случае это текущая директория)

Откройте скопированный файл и замените его содержимое на следующее:

```python
from flask import Flask, request
from getpass import getpass
from mysql.connector import connect, Error

connection = None

def init_db():
    global connection
    try:
        print('Connection to db:', end='')
        connection = connect(host='db', user='root', password='123')
        print('ОК')

        print('Create db:', end='')
        create_db_query = "CREATE DATABASE IF NOT EXISTS vars"
        with connection.cursor() as cursor:
            cursor.execute(create_db_query)
        print('ОК')
            
        print('Change db:', end='')                        
        use_db_query = "USE vars"
        with connection.cursor() as cursor:
            cursor.execute(use_db_query)
        print('ОК')
                           
        print('Create table:', end='')
        create_table_query = """
        CREATE TABLE IF NOT EXISTS vars(
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(100),
            value VARCHAR(100),
            UNIQUE (name)
            )
            """
        with connection.cursor() as cursor:
            cursor.execute(create_table_query)
            connection.commit()  
        print('ОК')     
    except Error as e:
        print('Failure', e)


app = Flask(__name__)

@app.route('/var/<var_name>', methods=['GET'])
def get(var_name):
    select_query = f"""
    SELECT value FROM vars
    WHERE name = '{var_name}'
    """
    
    print("Select query:", select_query)
    with connection.cursor() as cursor:
        cursor.execute(select_query)
        return cursor.fetchall()[0][0]
    
    
@app.route('/var/<var_name>', methods=['POST'])
def set(var_name):
    value = request.form.get("value")
    insert_query = f"""
    INSERT INTO vars (name, value)
    VALUES ('{var_name}', '{value}')
    ON DUPLICATE KEY UPDATE value='{value}'
    """
    
    print("Insert query:", insert_query)
    with connection.cursor() as cursor:
        cursor.execute(insert_query)
        connection.commit()
        
    return 'OK'


if __name__ == "__main__":
    init_db()
    app.run(debug=True, host='0.0.0.0')
```

Сохраните файл и скопируйте его обратно в контейнер:

- `docker cp app.py flask_base:/app/app.py`

> Первый аргумент - это файл на хост-машине, который будем копировать, второй аргумент - <имя или id контейнера>:<путь к файлу>

Мы изменили в контейнере всё, что хотели, теперь из него можно сделать образ (ну или просто запустить (`docker start`)):

- `docker commit flask_base var_keeper:latest`

> Первый аргумент имя или id контейнера, второй аргумент имя и тег.

Убедитесь, что новый образ появился в списке.

Теперь проверим работоспособность получившегося образа.

Как видно из кода, скрип, который теперь находится в `app.py`, обращается к базе данных. Поэтому сначала запустите контейнер с `mysql`.

- `docker run -d --name=db --network=tutorial -v vars:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123 mysql`

> Здесь мы создаём новый `mysql` контейнер с сервером БД и запускаем его в фоновом режиме; имя контейнера `db`; контейнер подключён к сети `tutorial` (и доступен там по имени `db`); кроме того, мы создаём и монтируем новый том `vars` к каталогу `/var/lib/mysql` в контейнере (чтобы хранить базу на хост машине); пароль пользователя `root` установлен в `123` через переменную среды `MYSQL_ROOT_PASSWORD`.

Теперь запустите контейнер из образа `var_keeper:latest`:

- `docker run -d --name=keeper --network=tutorial -p 5000:5000 var_keeper`

В коде есть отладочные принты, но контейнер в фоновом режиме не выводит информацию на экран. Чтобы её посмотреть выполните команду:

- `docker logs keeper`

Если всё работает правильно, то в начале (перед выводом flask) должно быть напечатано:
```
Connection to db:ОК
Create db:ОК
Change db:ОК
Create table:ОК
```

Проверьте работоспособность контейнера при помощи браузера. При отправке приложению POST запроса на роут `/var/<имя переменной>` значение должно добавляться в базу данных, а при отправке GET запроса - извлекаться из базы и выводится на экран.

Для отправки POST запроса можно ввести в строку адреса:

```html
data:text/html,<form action=http://localhost:5000/var/a method=post><input name=value></form>
```

и нажать Enter. На экране появится поле ввода. Введённое значение будет отправлено на `/var/a` и сервер запомнит новую переменную `a`.

Затем отправьте GET запрос (просто перейдите по http://localhost:5000/var/a) в браузере должно появиться то значение, которое вы вводили ранее.

#### 7. Отправляем образ на DockerHub

Перед выполнением рекомендуется посмотреть [обзорное видео по DockerHub](https://youtu.be/ERvC8RAr4YQ). Придётся проскипать рекламу, но тут наиболее полный обзор из тех, что нашёл на Youtube.

Зарегистрируетесь на https://hub.docker.com и зайдите под своей учёткой (возможно понадобится VPN);  
Откройте терминал и введите команду:

- `docker login`

Введите имя пользователя и пароль, от dockerhub;

Добавьте образу `var_keeper` ещё одно имя `<имя пользователя DockerHub>/var_keeper`. В моём случае так:

- `docker tag var_keeper:latest vladimirchabanov/var_keeper:latest`

> Как обычно `latest` можно не указывать.

> Новое имя и тег могут быть любыми.

Отправьте образ на DockerHub командой `docker push`. В моём случае так:

- `docker push vladimirchabanov/var_keeper`

> Теперь ваш образ доступен где угодно по имени репозитория. Т.е. его можно указывать в `Dockerfile`, `docker run`, `docker push` и т.д.

Например в моём случае:

- `docker run vladimirchabanov/var_keeper`

Полное название загруженного на DockerHub образа приведите в отчёте.

**Внимание:** если образ не будет доступен для скачивания, работа не будет зачтена.

## Вопросы к практическому заданию

1. Как запустить контейнер в интерактивном режиме?
2. Что нужно сделать, чтобы при вводе команд docker не нужно было вводить sudo?
3. Каким образом можно соединить 2 контейнера в отдельную для них сеть?
4. Два контейнера хотят обмениваться файлами. Каким образом можно организовать такое взаимодействие?
5. Мне нужен образ с wordpress на основе дистрибутива alpine. Приведите команду которой я могу скачать такой образ с dockerhub (версию wordpress и php выберите любую).

## Источники

1. docker-ci-cd-tutorial: https://github.com/Clemsazert/docker-ci-cd-tutorial
2. Изучаем Docker основы [все части]: https://habr.com/ru/company/ruvds/blog/438796/
3. Объяснение концепции сетей в Docker: https://itisgood.ru/2019/10/29/objasnenie-koncepcii-setej-v-docker/
4. Взаимодействие Docker контейнеров: https://dotsandbrackets.com/communication-between-docker-containers-ru/
5. Python и MySQL: практическое введение: https://proglib.io/p/python-i-mysql-prakticheskoe-vvedenie-2021-01-06
6. Docker compose - группы контейнеров: https://youtu.be/4KbL5lbjK-M
7. Обзорное видео по DockerHub: https://youtu.be/ERvC8RAr4YQ
8. Как успешно реализовать проверку состояния контейнера в Docker Compose: [длинная ссылка](https://medium.com/nuances-of-programming/как-успешно-реализовать-проверку-состояния-контейнера-в-docker-compose-6e3b449018b7)

## Отчёт

Оформите отчёт в соответствии с шаблоном и загрузите его в элемент Задание с номером работы в мудле.
